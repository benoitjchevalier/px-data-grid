<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../vaadin-grid/vaadin-grid.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-sorter.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-tree-toggle.html">
<link rel="import" href="../px-spinner/px-spinner.html">
<link rel="import" href="../px-modal/px-modal.html">
<link rel="import" href="../px-icon-set/px-icon.html"/>
<link rel="import" href="px-data-grid-column.html">
<link rel="import" href="px-auto-filter-field.html">
<link rel="import" href="px-data-grid-theme.html">
<link rel="import" href="px-data-grid-selection-column.html">
<link rel="import" href="px-data-grid-toggle-details-column.html">
<link rel="import" href="../app-localize-behavior/app-localize-behavior.html"/>
<link rel="import" href="../px-moment-imports/px-moment-imports.html"/>

<link rel="import" href="px-data-grid-string-renderer.html">
<link rel="import" href="px-data-grid-date-renderer.html">
<link rel="import" href="px-data-grid-number-renderer.html">
<link rel="import" href="px-data-grid-cell-content-wrapper.html">
<link rel="import" href="px-data-grid-filter.html">
<link rel="import" href="px-data-grid-filters-modal.html">
<link rel="import" href="px-data-grid-filters-preview.html">
<link rel="import" href="px-data-grid-sorter.html">
<link rel="import" href="px-data-grid-edit-buttons.html">

<link rel="import" href="px-data-grid-filterable-mixin.html">

<link rel="import" href="css/px-data-grid-styles.html">

<dom-module id="px-data-grid">
  <template>
    <style include="px-data-grid-styles"></style>

    <template is="dom-if" if="{{_showActionBar(autoFilter, hideActionMenu, filterable)}}">

      <div class="action-bar">
        <template is="dom-if" if="[[autoFilter]]">
          <px-auto-filter-field
            placeholder="[[localize('Search Table')]]"
            on-filter-change="_autoFilterChanged"
            value="{{_autoFilterValue}}"
          >
          </px-auto-filter-field>
        </template>

        <div class="action-bar__right">
          <template is="dom-if" if="[[filterable]]">
            <px-data-grid-filters-modal filters="{{_filters}}" columns="[[columns]]" localize="[[_boundedLocalize]]" initial-filter-state="[[_initialFilterState]]"></px-data-grid-filters-modal>
          </template>

          <template is="dom-if" if="[[!hideActionMenu]]">
            <px-dropdown multi hide-selected
              display-value="[[localize('Actions')]]"
              items="[[_actionMenuContent]]"
              selected-values="[[_selectedActionItems]]"
              disable-clear
              on-px-dropdown-click="_actionClicked">
            </px-dropdown>
          </template>
        </div>

      </div>
    </template>

    <px-data-grid-filters-preview filters="[[_filters]]" columns="[[columns]]" localize="[[_boundedLocalize]]"></px-data-grid-filters-preview>

    <vaadin-grid size="[[size]]"
                 data-provider="[[_currentDataProvider]]"
                 active-item="[[activeItem]]"
                 column-reordering-allowed="[[columnReorderingAllowed]]"
                 expanded-items="[[expandedItems]]"
                 striped$="[[_isStriped(striped,_groupByColumn)]]"
                 selected-items="{{selectedItems}}"
                 multi-sort="[[multiSort]]"
                 item-id-path="[[itemIdPath]]"
                 page-size="{{pageSize}}"
                 auto-height$="[[_isAutoHeight(gridHeight)]]"
                 loading="{{_loading}}">

      <template is="dom-if" if="[[_isSelectable(selectionMode)]]" restamp>
        <px-data-grid-selection-column frozen auto-select hidden="[[hideSelectionColumn]]" multi-select="[[_isMultiSelect(selectionMode)]]" tree-grid="[[_groupByColumn]]">
        </px-data-grid-selection-column>
      </template>

      <template is="dom-if" if="[[rowDetails]]" restamp>
        <px-data-grid-toggle-details-column frozen>
        </px-data-grid-toggle-details-column>
      </template>

      <template is="dom-repeat" items="[[columns]]" as="column">
        <px-data-grid-column
          name="[[column.name]]"
          path="[[column.path]]"
          hidden="[[column.hidden]]"
          localize="[[_boundedLocalize]]"
          type="[[column.type]]"
          frozen="[[_undefinedToFalse(column.frozen)]]"
          resizable="[[_checkColumnResizable(resizable, column.resizable)]]"
          mapped-object="[[column]]"
          width="[[_getColumnWidth(column)]]"
          flex-grow="[[_getColumnFlexGrow(column)]]"
          on-column-change="_onColumnUpdate"
          is-remote-data-provider="[[!_hasLocalDataProvider]]"
          is-data-column="true">
          <template class="header">
            <px-data-grid-sorter path="[[_resolveColumnPath(column)]]">[[resolveColumnHeader(column)]]</px-data-grid-sorter>
          </template>

          <template>

            <dom-if if="[[_isGroupedByColumn(column, _groupByColumn)]]">
              <template>
                <vaadin-grid-tree-toggle leaf="[[!item.hasChildren]]" expanded="{{expanded}}" level="[[level]]">
                  <template is="dom-if" if="[[item.hasChildren]]">
                    <template is="dom-if" if="[[!expanded]]">
                      <px-icon icon="px-utl:chevron-right"></px-icon>
                    </template>
                    <template is="dom-if" if="[[expanded]]">
                      <px-icon icon="px-utl:chevron"></px-icon>
                    </template>
                  </template>
                  <px-data-grid-cell-content-wrapper cell-color="[[_resolveCellColor(item, column, _highlightEntities.*)]]" item="{{item}}" column="[[column]]" localize="[[_boundedLocalize]]">
                  </px-data-grid-cell-content-wrapper>
                </vaadin-grid-tree-toggle>
              </template>
            </dom-if>

            <dom-if if="[[!_isGroupedByColumn(column, _groupByColumn)]]">
              <template>
                <px-data-grid-cell-content-wrapper cell-color="[[_resolveCellColor(item, column, _highlightEntities.*, _editingItem)]]" item="{{item}}" column="[[column]]" localize="[[_boundedLocalize]]">
                </px-data-grid-cell-content-wrapper>
              </template>
            </dom-if>
          </template>
        </px-data-grid-column>
      </template>

      <template is="dom-if" if="[[editable]]" restamp>
        <px-data-grid-column
          flex-grow="0">
          <template>
            <dom-if if="[[!_isAnyItemEditing(_editingItem)]]">
              <template>
                <px-icon icon="px-utl:edit" on-click="_setEditingItem"></px-icon>
              </template>
            </dom-if>
            <dom-if if="[[_isItemEditing(item, _editingItem)]]">
              <template>
                <px-data-grid-edit-buttons save="[[_boundedSaveItem]]" cancel="[[_boundedCancelEdit]]"></px-data-grid-edit-buttons>
              </template>
            </dom-if>
          </template>
        </px-data-grid-column>
      </template>
    </vaadin-grid>

    <px-spinner size="40" hidden$="[[_spinnerHidden]]"></px-spinner>
  </template>
  <script>
    {
      /**
       * @mixes Predix.DataGridFilterableMixin
       */
      class DataGridElement extends Predix.DataGridFilterableMixin(
        Polymer.mixinBehaviors([Polymer.AppLocalizeBehavior], Polymer.Element)
      ) {

        static get is() {
          return 'px-data-grid';
        }

        static get properties() {
          return {

            /**
             * Data for the table to display.
             *
             * Expected data format is a JSON array of objects. Each object in the array represents a row in the table.
             *
             * Each item in an object will be displayed as a separate column, unless px-data-table-columns are
             * defined to limit which columns are displayed.
             */
            tableData: {
              type: Array,
              notify: true
            },

            /**
             * If true, hides the column with checkboxes.
             */
            hideSelectionColumn: {
              type: Boolean,
              value: false
            },

            /**
             * An array that contains the selected items.
             */
            selectedItems: {
              type: Array,
              value: () => [],
              notify: true
            },

            /**
             * The total number of items
             */
            size: {
              type: Number,
              value: undefined
            },

            /**
             * Number of items fetched at a time from the dataprovider.
             */
            pageSize: {
              type: Number,
              value: undefined
            },

            /**
             * When `true`, user can sort by multiple columns
             */
            multiSort: {
              type: Boolean,
              value: false
            },

            /**
             * Current selection mode of grid. Accepts values 'none', 'single' and 'multi'.
             */
            selectionMode: {
              type: String,
              value: 'none',
              observer: '_selectionModeChanged'
            },

            /**
             * The item user has last interacted with. Turns to `null` after user deactivates
             * the item by re-interacting with the currently active item.
             */
            activeItem: {
              type: Object,
              notify: true,
              value: null
            },

            /**
             * When `true`, user can resize columns
             */
            resizable: {
              type: Boolean,
              value: false
            },

            /**
             * When `true`, user can edit data
             */
            editable: {
              type: Boolean,
              value: false
            },

            /**
             * Set to true to allow column reordering.
             */
            columnReorderingAllowed: {
              type: Boolean,
              value: false
            },

            /**
             * An array containing references to expanded items.
             */
            expandedItems: {
              type: Array,
              value: []
            },

            /**
             * Set to true to enable a togglable row details container. This container
             * is hidden by default, but can be opened by clicking the chevron icon to left
             * of the row.
             */
            rowDetails: {
              type: Boolean,
              value: false,
              observer: '_onRowDetailsChange'
            },

            /**
             * Define if table action menu should be hidden.
             */
            hideActionMenu: {
              type: Boolean,
              value: false
            },

            /**
             * Grid columns. If no columns are passed, grid generates columns from passed data.
             * Format:
             * ```javascript
             * {
             *   id: 'first[string]',
             *   name: 'First Name',
             *   path: 'first',
             *   type: 'string',
             *   renderer: 'px-data-grid-string-renderer',
             *   minBound: 1,
             *   maxBound: 10,
             *   hidden: false,
             *   frozen: false,
             *   required: false,
             *   flexGrow: 1
             * }
             * ```
             *
             * ** column.id **
             *
             * Note, that if `column.id` is not manually passed, the grid will automatically generate it
             * from `column.path` and `column.type`. In that case `column.id` will be equal `column.path[column.type]`.
             * There can't be 2 columns with the same id.
             * Also, note, that `-any-` is reserved keyword for `column.id`, you should not use it.
             *
             * ** column.name **
             *
             * Name, that is displayed in column header.
             *
             * ** column.path **
             *
             * Column's path indicates a key, which is used to get data from data object.
             *
             * ** column.type **
             *
             * Type of column influences on advanced filter's UI. Different selectors will be displayed for different types.
             *
             * ** column.renderer **
             *
             * You can define your own renderer element to display and edit cell data in your own way.
             * For more information, please check sample renderers, e.g. `px-data-grid-number-renderer`, `px-data-grid-date-renderer`.
             *
             * ** column.minBound **
             *
             * Used to define minimum bound of a number in advanced filter's slider.
             * Note, that this property works with `column.type === 'number'` only.
             *
             * ** column.maxBound **
             *
             * Used to define maximum bound of a number in advanced filter's slider.
             * Note, that this property works with `column.type === 'number'` only.
             *
             * If both minBound and maxBound properties are defined, advanced filter will display slider instead of dropdown.
             *
             * ** column.hidden **
             *
             * Indicates whether a column is hidden.
             *
             * ** column.frozen **
             *
             * Indicates whether a column is frozen.
             *
             * ** column.required **
             *
             * This property is used in renderers to validate data when user edits it.
             *
             * ** column.flexGrow **
             *
             * Indicates whether a column should grow.
             *
             */
            columns: {
              type: Array,
              value: () => [],
              observer: '_columnsChanged'
            },

            /**
             * Copy of last columns value received, to be used with reset layout
             */
            _lastColumnsReceived: {
              type: Array,
              value: () => []
            },

            /**
             * Content of action menu
             */
            _actionMenuContent: {
              type: Array
            },

            /**
             * A valid IETF language tag as a string that `app-localize-behavior` will
             * use to localize this component.
             *
             * See https://github.com/PolymerElements/app-localize-behavior for API
             * documentation and more information.
             */
            language: {
              type: String,
              value: 'en'
            },

            /**
             * Use the key for localization if value for that language is missing.
             * Should always be true for Predix components.
             */
            useKeyIfMissing: {
              type: Boolean,
              value: true
            },

            /**
             * Library object of hardcoded strings used in this application.
             * Used by `app-localize-behavior` in conjunction with `language`.
             */
            resources: {
              type: Object,
              value: () => {
                // can also load these from external file as shown here:
                // https://www.polymer-project.org/2.0/toolbox/localize
                return {
                  'en': {
                    'Actions': 'Actions',
                    'Freeze column': 'Freeze Column',
                    'Unfreeze column': 'Unfreeze Column',
                    'Group by column': 'Group by Column',
                    'Ungroup': 'Ungroup',
                    'Hide column': 'Hide Column'
                  },
                  'fr': {
                    'Actions': 'Actions',
                    'Value is required': 'Pakollinen arvo'
                  },
                  'fi': {
                    'Actions': 'Toiminnot',
                    'Hide column': 'Piilota sarake'
                  }
                };
              }
            },

            /**
             * All custom table actions shown before columns. Arrays should contain objects
             * with name (String, shown to user) and id (String, given back in event).
             * When user selects these actions table-action event will be emitted, with id of
             * action at event.detail.id
             */
            tableActions: {
              type: Array,
              value: []
            },

            /**
             * Function that provides items lazily. Receives arguments params, callback
             */
            remoteDataProvider: {
              type: Function,
              observer: '_remoteDataProviderChanged'
            },

            _currentDataProvider: {
              type: Function
            },

            /**
             * If true, every other row in the table will appear with a background color to improve visual scanning.
             * When grouped by column striping will be disabled.
             */
            striped: {
              type: Boolean,
              value: false
            },

            /**
             * Shows if there is any pending request for remote data.
             */
            _loading: {
              type: Boolean,
              value: false,
              observer: '_loadingChanged'
            },

            _spinnerHidden: {
              type: Boolean,
              value: true
            },

            /**
             * How many milliseconds before loading spinner will be shown
             */
            loadingSpinnerDebounce: {
              type: Number,
              value: 500
            },

            /**
             * To enable automatic filtering change property to true
             */
            autoFilter: {
              type: Boolean,
              value: false
            },

            /**
             * Array of objects of conditions used to highlight specific columns.
             * Format:
             * ```javascript
             * {
             *   type: 'cell',
             *   condition: (cellContent, column, item) => { return cellContent == 'John Doe' },
             * },
             * {
             *   type: 'row',
             *   condition: (cellContent, item) => { return cellContent[0] == 'a' },
             *   color: '#a8a8a8'
             * },
             * {
             *   type: 'column',
             *   condition (column, item) => { return column.name == 'age' },
             *   color: 'pink'
             * }
             * ```
             */
            highlight: {
              type: Array,
              value: () => []
            },

            /**
             * Concatenated array from user's highlights and filter's
             */
            _highlightEntities: {
              type: Array,
              value: () => []
            },

            /**
             * When true data provider is local, when false external (remote) and
             * when undefined it defined yet.
             */
            _hasLocalDataProvider: {
              type: Boolean
            },

            /**
             * Default column width if not defined, eg. '100px'
             */
            defaultColumnWidth: {
              type: String,
              value: '100px'
            },

            /**
             * Default column flex if not defined, eg. 1
             */
            defaultColumnFlex: {
              type: Number,
              value: 1
            },

            _selectedActionItems: {
              type: Array,
              value: []
            },

            _groupByColumn: {
              type: Object,
              value: false
            },

            /**
             * Define height of grid. If 'auto' the height of grid will match with
             * match with number of rows in grid. Undefined value and 'default'
             * will use default height. Any other value (eg. '400px') is given as
             * CSS height value to the actual grid component inside px-data-grid.
             */
            gridHeight: {
              type: String,
              reflectToAttribute: true,
              observer: '_gridHeightChanged'
            },

            /**
             * Path to an item sub-property that identifies the item.
             */
            itemIdPath: {
              type: String,
              value: null
            },

            /**
             * Stores item, that is currently in edit mode.
             */
            _editingItem: {
              type: Object,
              value: null,
              observer: '_editingItemObserver'
            },

            /**
             * Stores all renderer elements for item, that is currently in edit mode.
             */
            _editingRenderers: {
              type: Array,
              value: () => []
            },

            _boundedLocalize: Function,

            _autoFilterValue: {
              type: String
            }
          };
        }

        static get observers() {
          return [
            '_highlightsObserver(highlight, _filterHighlights, highlight.*, _filterHightlights.*)',
            '_localizeChanged(localize)',
            '_tableDataChanged(tableData, isAttached)',
            '_setColumnId(columns, columns.*)'
          ];
        }

        updateColumns() {
          const probs = ['hidden', 'name', 'frozen', 'width', 'flexGrow', 'path'];
          for (let i = 0; i < this.columns.length; ++i) {
            const prefix = 'columns.' + i + '.';
            probs.forEach(prob => {
              const path = prefix + prob;
              this.notifyPath(path);
            });
          }
        }

        constructor() {
          super();
          this._observer = new Polymer.FlattenedNodesObserver(this, info => {
            this._checkRowDetailsTemplate(info.addedNodes);
          });
        }

        _checkRowDetailsTemplate(nodes) {
          const rowDetailsTemplate = nodes.filter(node => {
            return node.localName && node.localName === 'template' && node.className && node.className.indexOf('row-details') !== -1;
          });
          if (rowDetailsTemplate.length) {
            this._vaadinGrid._rowDetailsTemplate = rowDetailsTemplate[0];

            const templatizer = new Vaadin.Grid.Templatizer();
            templatizer._grid = this._vaadinGrid;
            templatizer.dataHost = this._vaadinGrid.dataHost;
            templatizer.template = this._vaadinGrid._rowDetailsTemplate;
            this._vaadinGrid._rowDetailsTemplate.templatizer = templatizer;

            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => {
              Array.from(this._vaadinGrid.$.items.children).forEach(row => {
                this._vaadinGrid._updateRow(
                  row,
                  this._vaadinGrid._columnTree[this._vaadinGrid._columnTree.length - 1]
                );
              });
            });
          }
        }

        ready() {
          super.ready();

          this._vaadinGrid = this.shadowRoot.querySelector('vaadin-grid');
          this._vaadinGrid._pxDataGrid = this;
          this._vaadinGrid.addEventListener('px-sorter-changed', this._onPxSorterChanged);

          // Attach scroll listener for styling
          this._boundedScrollListener = this._scrollListener.bind(this);
          this._vaadinGrid.$.outerscroller.addEventListener('scroll', this._boundedScrollListener);

          // Override selectItem method to allow easy single select handling
          this._vaadinGrid.selectItem = (item) => this._handleSelectItem(item);

          this.addEventListener('column-froze', (event) => this._handleColumnFroze(event));

          this.addEventListener('column-unfroze', (event) => {
            const columnsRow = this._vaadinGrid._columnTree[this._vaadinGrid._columnTree.length - 1].slice(0);
            const lastFrozen = columnsRow.filter((column) => column._lastFrozen)[0];
            if (lastFrozen) {
              this._vaadinGrid.insertBefore(event.detail.column, lastFrozen.nextSibling);
            }
          });

          this.addEventListener('group-by-column', (event) => {
            this._groupByColumn = event.detail.column;
            this._vaadinGrid.clearCache();
            this._vaadinGrid.setAttribute('tree-grid', true);
          });

          this.addEventListener('ungroup', (event) => {
            this._ungroup();
          });

          this._boundedCancelEdit = this._cancelEdit.bind(this);
          this._boundedSaveItem = this._saveItem.bind(this);

          document.addEventListener('renderer-editing-changed', (event) => {
            const renderer = event.detail.renderer;
            if (renderer._editing) {
              this._editingRenderers.push(renderer);
            } else {
              this._editingRenderers.splice(this._editingRenderers.indexOf(renderer), 1);
            }
          });
        }

        _ungroup() {
          this._groupByColumn = false;
          this._vaadinGrid.clearCache();
          this._vaadinGrid.removeAttribute('tree-grid');
        }

        _handleColumnFroze(event) {
          const columnsRow = this._vaadinGrid._columnTree[this._vaadinGrid._columnTree.length - 1].slice(0);
          const dataColumns = columnsRow.filter(c => c.isDataColumn);
          if (dataColumns.length) {
            this._vaadinGrid.insertBefore(event.detail.column, dataColumns[0]);
            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
          }
        }

        /**
         * Trick to prevent multiselection when in single select mode
         */
        _handleSelectItem(item) {
          if (!this._vaadinGrid._isSelected(item)) {
            if (!this._isMultiSelect()) {
              this._vaadinGrid.selectedItems = [];
            }
            this._vaadinGrid.push('selectedItems', item);
          }
        }

        _getValue(column, item) {
          if (column && item) {
            return this.get(column.path, item);
          } else {
            return undefined;
          }
        }

        _getColumnWidth(column) {
          return column.width ? column.width : this.defaultColumnWidth;
        }

        _getColumnFlexGrow(column) {
          return column.flexGrow === undefined ? this.defaultColumnFlex : column.flexGrow;
        }

        _resolveCellColor(item, column) {
          if (!this._highlightEntities || item === undefined) {
            return undefined;
          }

          let columnColor;
          let rowColor;
          let cellColor;

          this._highlightEntities.forEach((highlightEntity) => {
            if (highlightEntity.type === 'row') {
              if (this._isRowConditionApplied(item, highlightEntity.condition)) {
                if (highlightEntity.color) {
                  rowColor = highlightEntity.color;
                } else {
                  rowColor = 'default';
                }
              }
            } else if (highlightEntity.type === 'column') {
              if (this._isColumnConditionApplied(column, highlightEntity.condition)) {
                if (highlightEntity.color) {
                  columnColor = highlightEntity.color;
                } else {
                  columnColor = 'default';
                }
              }
            } else {
              const value = this._getValue(column, item);
              if (highlightEntity.condition(value, column, item)) {
                if (highlightEntity.color) {
                  cellColor = highlightEntity.color;
                } else {
                  cellColor = 'default';
                }
              }
            }
          });

          const finalColor = cellColor ? cellColor : (rowColor ? rowColor : (columnColor ? columnColor : undefined));
          return finalColor;
        }

        _isRowConditionApplied(item, condition) {
          return !!this.columns.filter(column => {
            const cellText = this.get(column.name, item);
            return condition(cellText, item);
          }).length;
        }

        _isColumnConditionApplied(column, condition) {
          const cachedItems = this._vaadinGrid._cache.items;
          const itemsArray = Object.keys(cachedItems).map(key => cachedItems[key]);

          return !!itemsArray.filter(item => {
            return condition(column, item);
          }).length;
        }

        _tableDataChanged(tableData, isAttached) {
          if (!isAttached) {
            return;
          }

          if (tableData) {
            this._currentDataProvider = (params, callback) => {
              this._localDataProvider(params, (items, size) => {
                callback(items, size);
                this._populateTableColumns(items);
              });
            };
            this._hasLocalDataProvider = true;
          }
          this._editingItem = null;
        }

        /**
         * Do not drop item for page sizing here, or it will break things
         */
        _localDataResolver(params, items) {
          if (params.filters && params.filters.length && this._vaadinGrid._checkPaths(params.filters, 'filtering', items)) {
            items = this._applyAutoFilter(items, params.filters);
          }

          // TODO: these values should be in params!
          if (this._filters && this._filters.length != 0) {
            items = this._applyCustomFilter(items, this.columns, this._filters);
          }

          if (params.sortOrders && params.sortOrders.length && this._vaadinGrid._checkPaths(this._sorters, 'sorting', items)) {
            const multiSort = (a, b) => {
              return params.sortOrders.map(sort => {
                if (sort.direction === 'asc') {
                  return this._compare(Polymer.Base.get(sort.path, a), Polymer.Base.get(sort.path, b));
                } else if (sort.direction === 'desc') {
                  return this._compare(Polymer.Base.get(sort.path, b), Polymer.Base.get(sort.path, a));
                }
                return 0;
              }).reduce((p, n) => {
                return p ? p : n;
              }, 0);
            };

            items = items.slice(0).sort(multiSort);
          }

          // Do not apply pageSize slice here, it will break sizing

          return items;
        }

        _localDataProvider(params, callback) {
          let items = Array.isArray(this.tableData) ? this.tableData : [];
          if (this._groupByColumn) {
            const columnPath = this._groupByColumn.path;
            if (!params.parentItem) {
              const valuesMap = items.reduce((map, item) => {
                const value = item[columnPath];
                const groupItem = Object.assign({}, item);
                for (const i in groupItem) { // px-data-grid/issues/160
                  if (i !== columnPath) {
                    groupItem[i] = '';
                  }
                }
                groupItem.hasChildren = true;
                map.set(value, groupItem);
                return map;
              }, new Map());
              items = [];
              valuesMap.forEach((item) => items.push(item));
            } else {
              items = items.filter((item) => item[columnPath] === params.parentItem[columnPath]);
            }
          }
          items = this._localDataResolver(params, items);

          const totalSize = items.length;

          const start = params.page * params.pageSize;
          const end = start + params.pageSize;
          items = items.slice(start, end);

          callback(items, totalSize);
        }

        /**
         * Will return all local items after filter (no ordering applied)
         */
        _getAllLocalItems() {
          if (this._hasLocalDataProvider) {
            const items = (Array.isArray(this.tableData) ? this.tableData : []).slice(0);
            return this._localDataResolver({
              page: 0,
              pageSize: this.tableData.length
            }, items);
          } else {
            return [];
          }
        }

        _remoteDataProviderChanged(provider) {
          this._hasLocalDataProvider = false;
          this._currentDataProvider = (params, callback) => {
            provider(params, (items, size) => {
              callback(items, size);
              this._populateTableColumns(items);
            });
          };
        }

        _resolveColumnPath(column) {
          if (typeof column.path === 'undefined') {
            console.warn(`column.path for column ${JSON.stringify(column)} should be initialized.`);
          }
          return column.path ? column.path : '';
        }

        _populateTableColumns(data) {
          if (!this.columns.length && data && data.length) {
            this.columns = [];
            for (const key in data[0]) {
              this.push('columns', {
                name: key,
                hidden: false,
                editable: true,
                renderer: 'px-data-grid-string-renderer',
                type: 'string',
                path: key,
                generated: true
              });
            }
          }

          this._updateActionMenu();
        }

        /**
         * Event handler for action menu clicks
         */
        _actionClicked(evt) {
          const item = evt.detail.detail.item;
          const key = item.key;

          if (key && typeof key == 'string') {
            // -column- is temporary work around to limitations of px-dropdown
            if (key.indexOf('-column-') === 0) {
              const columnName = key.substr('-column-'.length);
              this._getColumnsWithName(columnName).forEach((c) => {
                c.hidden = c.hidden === undefined ? true : !c.hidden;
              });
            } else if (key.indexOf('-action-') === 0) {
              const actionId = key.substr('-action-'.length);
              this.dispatchEvent(new CustomEvent('table-action', {
                detail: {
                  id: actionId
                },
                bubbles: true
              }));
            } else if (key.indexOf('-internal-ungroup-') === 0) {
              this._ungroup();
            }
          }
        }

        /**
         * Function to resolve (data) columns on grid
         */
        _getColumns() {
          if (this._vaadinGrid && this._vaadinGrid._columnTree) {
            return this._vaadinGrid._columnTree[0].filter(c => c.isDataColumn);
          } else if (this.columns && this.columns.length) {
            return this.columns.map((c) => {
              return c._element ? c._element : c;
            });
          } else {
            return [];
          }
        }

        /**
         * Function called when action menu content needs to be updated
         */
        _updateActionMenu() {
          const content = [];
          this._selectedActionItems = [];

          // Application specific options

          if (this.tableActions) {
            this.tableActions.forEach((item) => {
              content.push({
                key: '-action-' + item.id,
                val: item.name,
                selected: false,
                disableSelect: true
              });
            });
          }

          if (this._groupByColumn) {
            content.push({
              key: '-internal-ungroup-',
              val: this.localize('Clear Grouping'),
              selected: false,
              disableSelect: true
            });
          }

          // Add column hide/show selection

          const defaultName = this.localize('Column #');
          let counter = 0;
          const selected = [];

          this._getColumns().forEach((columnElement) => {
            const index = ++counter;
            const hidden = columnElement.hidden ? columnElement.hidden : false;
            const name = columnElement.name ? columnElement.name : (defaultName + index);
            // -column- is temporary work around to limitations of px-dropdown
            const key = '-column-' + name;

            const item = {
              key: key,
              val: name
            };

            if (!hidden) {
              selected.push(key);
            }

            content.push(item);
          });

          this._actionMenuContent = content;
          this._selectedActionItems = selected;
        }

        _getColumnsWithName(name) {
          return this._getColumns().filter(c => c.name == name);
        }

        _getColumnById(columnId) {
          return this.columns.filter((column) => column.id === columnId)[0];
        }

        _onColumnUpdate(event) {
          if (event.detail.type == 'hidden') {
            this._updateActionMenu();
          }
        }

        _loadingChanged(loading) {
          clearTimeout(this._spinnerHiddenTimeout);

          if (loading) {
            this._spinnerHiddenTimeout = setTimeout(() => this._spinnerHidden = false, this.loadingSpinnerDebounce);
          } else {
            this._spinnerHidden = true;
          }
        }

        /**
         * Simple method to check if action bar should be shown
         */
        _showActionBar(filterField, hideActionMenu, filterable) {
          return filterField || !hideActionMenu || filterable;
        }

        /**
         * Helper method to check if header is defined, if not use name
         */
        resolveColumnHeader(column) {
          return column.header ? column.header : column.name;
        }

        /**
         * This to be moved to inner data-provider when we get that done. Until then
         * this will add workaround that allows to filter inmemory data given via
         * items parameter.
         */
        _applyAutoFilter(items, filters) {
          return items.filter((item, index) => {
            return filters.filter(filter => {
              const filterValueLowercase = this._vaadinGrid._normalizeEmptyValue(filter.value).toString().toLowerCase();
              if (item && filter.path === undefined) {
                for (const key in item) {
                  const value = this._vaadinGrid._normalizeEmptyValue(Polymer.Base.get(key, item));
                  if (value.toString().toLowerCase().indexOf(filterValueLowercase) !== -1) {
                    return false;
                  }
                }
                return true;
              } else {
                const value = this._vaadinGrid._normalizeEmptyValue(Polymer.Base.get(filter.path, item));
                return value.toString().toLowerCase().indexOf(filterValueLowercase) === -1;
              }
            }).length === 0;
          });
        }

        /**
         * Listener for auto filter component
         */
        _autoFilterChanged(event) {
          // Ignore if autofiltering not enabled
          if (!this.autoFilter) {
            return;
          } else {
            const filters = [
              {
                value: event.detail.value
              }
            ];

            this._vaadinGrid._filters = filters;
            this._vaadinGrid.clearCache();
          }
        }

        _isGroupedByColumn(column, _groupByColumn) {
          return _groupByColumn && _groupByColumn.name === column.name;
        }

        /**
         * Method forcing column order rules. To be run after any column order change
         */
        _columnOrderCleaner() {
          const columnsRow = this._vaadinGrid._columnTree[this._vaadinGrid._columnTree.length - 1].slice(0);
          const leftColumns = columnsRow.filter(c => !c.isDataColumn && c.frozen);
          const rightColumns = columnsRow.filter(c => c.isDataColumn || !c.frozen);

          if (leftColumns && leftColumns.length && rightColumns && rightColumns.length) {
            const firstRight = rightColumns[0];
            leftColumns.forEach(c => {
              this._vaadinGrid.insertBefore(c, firstRight);
            });
          }
        }

        /**
         * Check if selections are allowed
         */
        _isSelectable() {
          return this.selectionMode == 'single' || this.selectionMode == 'multi';
        }

        /**
         * Check if grid is in multi selection mode
         */
        _isMultiSelect() {
          return this._isSelectable() && this.selectionMode == 'multi';
        }

        _selectionModeChanged(mode) {
          if (mode != 'none' && mode != 'single' && mode != 'multi') {
            console.warn('Invalid selection-mode value \'' + mode + '\', use \'none\', \'single\' or \'multi\'');
            return;
          }

          const selectable = mode != 'none';

          // clear selections if mode is 'none'
          if (mode === 'none' && this._vaadinGrid) {
            this._vaadinGrid.selectedItems = [];
          }

          // clear selections if mode is 'single' and there are more than 1 selected items
          if (mode === 'single' && this._vaadinGrid && this._vaadinGrid.selectedItems.length > 1) {
            this._vaadinGrid.selectedItems = [];
          }

          if (selectable) {
            setTimeout(() => {
              if (this.selectable) {
                this._columnOrderCleaner();
              }
            });
          }

          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
        }

        _highlightsObserver(highlight, filterHighlights) {
          this.set('_highlightEntities', highlight.concat(filterHighlights));
        }

        _gridHeightChanged(gridHeight) {
          if (!this._vaadinGrid) {
            return;
          }

          // In case of real undefined (or 'default' string, for demo cases)
          // and 'auto' the CSS height of vaadin-grid is set to undefined. Other
          // values are set as CSS height value to vaadin-grid.
          if (!this.gridHeight || this.gridHeight == 'default' || this.gridHeight == 'auto') {
            this._vaadinGrid.style.height = null;
          } else {
            this._vaadinGrid.style.height = this.gridHeight;
          }

          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
        }

        _onRowDetailsChange(rowDetails) {
          if (this._vaadinGrid && !rowDetails) {
            this._vaadinGrid.detailsOpenedItems = [];
          }
        }

        /**
         * Set visibility of the details container for any item's corresponding row.
         */
        setRowDetailsVisible(item, isVisible) {
          if (!item) {
            return;
          }
          const index = this._vaadinGrid.detailsOpenedItems.indexOf(item);
          if (isVisible && index < 0) {
            this._vaadinGrid.detailsOpenedItems.push(item);
            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
          } else if (!isVisible && index >= 0) {
            this._vaadinGrid.detailsOpenedItems.splice(index, 1);
            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
          }
        }

        _editingItemObserver(editingItem, oldV) {
          if (typeof oldV === 'undefined') {
            return;
          }

          this.dispatchEvent(new CustomEvent('editing-item-changed', {
            bubbles: true,
            composed: true,
            detail: {
              item: editingItem
            }
          }));
        }

        _setEditingItem(event) {
          // To prevent selections
          event.stopPropagation();
          this._editingItem = event.model.item;
        }

        _cancelEdit(event) {
          this._editingRenderers.forEach((renderer) => renderer.restoreInitial());
          this._editingItem = null;
        }

        _isItemEditing(item, editingItem) {
          return item === editingItem;
        }

        _isAnyItemEditing(editingItem) {
          return !!editingItem;
        }

        _saveItem() {
          if (this._editingRenderers.every((renderer) => renderer._performValidation().valid)) {
            const changedPaths = this._editingRenderers
              .filter((renderer) => renderer.applyValue())
              .map((renderer) => renderer.column.path);

            if (changedPaths.length > 0) {
              this.dispatchEvent(new CustomEvent('item-edited',
                {
                  bubbles: true,
                  composed: true,
                  detail: {
                    item: this._editingItem,
                    paths: changedPaths
                  }
                }
              ));
            }

            this._editingItem = null;
          }
        }

        _localizeChanged(localize) {
          this._boundedLocalize = localize.bind(this);
        }

        _scrollListener(e) {
          if (e.target.scrollLeft != 0) {
            this._vaadinGrid.setAttribute('horizontal-offset', 'true');
          } else {
            this._vaadinGrid.removeAttribute('horizontal-offset');
          }
        }

        /**
         * Overridden version of _onSorterChanged in vaadin-grid-sort-mixin. Is mapped to custom event
         * px-sorter-changed emitted by px-data-grid-sorter. Only difference is to use push, not
         * unshift, when adding sort rule to _sorters. If errors in this method, update to match with
         * current version in vaadin-grid-sort-mixin, and replace unshift with push.
         */
        _onPxSorterChanged(e) {

          this._pxDataGrid._editingItem = null;

          const sorter = e.target;

          this._removeArrayItem(this._sorters, sorter);
          sorter._order = null;

          if (this.multiSort) {
            if (sorter.direction) {
              this._sorters.push(sorter);
            }

            this._sorters.forEach((sorter, index) => sorter._order = this._sorters.length > 1 ? index : null, this);
          } else {
            this._sorters.forEach(sorter => {
              sorter._order = null;
              sorter.direction = null;
            });

            if (sorter.direction) {
              this._sorters = [sorter];
            }
          }

          e.stopPropagation();

          if (this.dataProvider &&
            // No need to clear cache if sorters didn't change
            JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
            this.clearCache();
          }

          this._a11yUpdateSorters();

          this._previousSorters = this._mapSorters();
        }

        _getOrderedColumns() {
          return this._vaadinGrid
            ._columnTree[this._vaadinGrid._columnTree.length - 1]
            .slice(0)
            .sort((a, b) => a._order - b._order)
            .map((col) => col.mappedObject);
        }

        /**
         * Get current visible columns in grid
         */
        getVisibleColumns() {
          return this._vaadinGrid
            ._columnTree[this._vaadinGrid._columnTree.length - 1]
            .slice(0)
            .sort((a, b) => a._order - b._order)
            .map((col) => col.mappedObject)
            .filter((col) => !col.hidden);
        }

        /**
         * Returns currently visible data if `true` parameter is passed or all cached data if no parameter is passed.
         */
        getData(visibleOnly) {
          let items = [];

          if (visibleOnly) {
            items = Array.from(this._vaadinGrid.querySelectorAll('px-data-grid-cell-content-wrapper'));

            const gridRect = this._vaadinGrid.getBoundingClientRect();
            const headerRect = this._vaadinGrid
              .querySelector('px-data-grid-header-cell')
              .getBoundingClientRect();

            items = items.filter((wrapper) => {
              const wrapperRect = wrapper.getBoundingClientRect();
              return wrapperRect.top < gridRect.bottom && wrapperRect.bottom > headerRect.bottom;
            }).map((wrapper) => {
              return wrapper.item;
            }).filter((v, i, a) => {
              return a.indexOf(v) === i && v;
            });
          } else {
            const cachedItems = this._vaadinGrid._cache.items;
            Object.keys(cachedItems).forEach((key) => {
              items.push(cachedItems[key]);
            });
          }

          return items.map((item) => {
            const sortedObject = {};

            this.getVisibleColumns().forEach((col) => {
              sortedObject[col.path] = item[col.path];
            });

            return sortedObject;
          });
        }

        /**
         * Make JSON friendly version out of columns array
         */
        _cleanColumns(columns) {
          if (!columns) {
            return [];
          }
          return this._copyArray(columns);
        }

        /**
         * Columns property change observer
         */
        _columnsChanged(columns) {
          // Store cleaned version of current columns
          this._lastColumnsReceived = this._cleanColumns(columns);
        }

        _setColumnId(columns) {
          if (!columns || this._columnIdSetting) {
            return;
          }

          this._columnIdSetting = true;
          columns.forEach((column, index) => {
            if (!column.id) {
              this.set(`columns.${index}.id`, `${column.path}[${column.type || 'string'}]`);

              if (columns.filter((col) => col.id === column.id).length > 1) {
                console.warn(`Warning! There are multiple columns with '${column.path}' path ` +
                  `and '${column.type || 'string'}' type, please provide column.id for those columns`);
              }
            }
          });
          this._columnIdSetting = false;
        }

        /**
         * Restore layout (columns) to state those were given
         */
        restoreLayout() {
          if (!this._lastColumnsReceived) {
            console.warn('No layout defined where to return');
            return;
          }
          // Store last columns received before clearing columns
          const revertTo = this._copyArray(this._lastColumnsReceived);
          this._revertColumns(revertTo);
        }

        _revertColumns(revertTo) {
          // First clear all columns
          this.columns = [];

          // After empty columns has been rendered return to wanted state
          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this.columns = revertTo);
        }

        /**
         * Just to make sure only true or false is given (undefined converted to false).
         * In some cases undefined value breaks functionality,
         */
        _undefinedToFalse(value) {
          if (value === undefined) {
            return false;
          } else {
            return value;
          }
        }

        _copyArray(arr) {
          return JSON.parse(JSON.stringify(arr));
        }

        _isAutoHeight(gridHeight) {
          return gridHeight === 'auto';
        }

        _checkColumnResizable(gridResizable, columnResizable) {
          return gridResizable ? (columnResizable === undefined ? true : columnResizable) : false;
        }

        _isStriped(striped, groupByColumn) {
          return striped && !groupByColumn;
        }

        /**
         * Rewrite of _compare from vaadin-grid to allow incasesensitive compare
         */
        _compare(a, b) {
          a = this._vaadinGrid._normalizeEmptyValue(a);
          b = this._vaadinGrid._normalizeEmptyValue(b);

          // If both are string, make sure values are compared incasesensitive
          // TODO localCompare would be better option, but not sure it's
          // fully supported, and what locale to use
          if (typeof a === 'string' && typeof b === 'string') {
            a = a.toUpperCase();
            b = b.toUpperCase();
          }

          if (a < b) {
            return -1;
          }
          if (a > b) {
            return 1;
          }
          return 0;
        }

        getState() {
          return {
            columns: this._copyArray(this._getOrderedColumns()),
            highlight: this.highlight.map(entity => Object.assign({}, entity)),
            filters: this._copyArray(this._filters),
            autoFilter: this._autoFilterValue
          };
        }

        setState(state) {
          this.columns = [];

          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => {
            this.columns = this._copyArray(state.columns);

            this._filters = state.filters;
            this._autoFilterValue = state.autoFilter;
            this.highlight = state.highlight;
          });
        }
      }
      customElements.define(DataGridElement.is, DataGridElement);

      /**
       * @namespace Predix
       */
      window.Predix = window.Predix || {};
      Predix.DataGridElement = DataGridElement;
    }
  </script>
</dom-module>
